// Generated by CoffeeScript 1.4.0
(function() {
  var PlistNode, PlistParser;

  PlistNode = (function() {

    function PlistNode(type, parent) {
      if (parent == null) {
        parent = null;
      }
      this.type = type;
      this.key = null;
      this.value = null;
      this.parent = parent;
      this.children = [];
      return this;
    }

    PlistNode.prototype.addChild = function(node) {
      node.parent = this;
      this.children.push(node);
      return node;
    };

    PlistNode.prototype.getParent = function() {
      if (this.parent) {
        return this.parent;
      }
      return this;
    };

    PlistNode.prototype.convert = function() {
      var child, iterable, _i, _j, _len, _len1, _ref, _ref1;
      if (!this.children.length) {
        if (this.type === 'integer') {
          return parseInt(this.value, 10);
        } else if (this.type === 'string') {
          return this.value;
        } else if (this.type === 'date') {
          try {
            return new Date(this.value);
          } catch (e) {
            return null;
          }
        } else if (this.type === 'true') {
          return true;
        } else if (this.type === 'false') {
          return false;
        } else if (this.type === 'real') {
          return parseFloat(this.value);
        } else if (this.type === 'data') {
          return decodeURIComponent(escape(window.atob(this.value)));
        } else if (this.type === 'dict') {
          return {};
        } else if (this.type === 'array') {
          return [];
        }
      } else {
        if (this.type === 'dict') {
          iterable = {};
          _ref = this.children;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            if (child.key) {
              iterable[child.key] = child.convert();
            }
          }
        } else if (this.type === 'array') {
          iterable = [];
          _ref1 = this.children;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            child = _ref1[_j];
            iterable.push(child.convert());
          }
        }
      }
      return iterable;
    };

    return PlistNode;

  })();

  PlistParser = (function() {

    function PlistParser(sax, xml) {
      this.sax = sax;
      this.xml = xml;
      this.traverser = null;
      this.last = {
        'parent': null,
        'node': null,
        'key': null,
        'tag': null,
        'value': null
      };
      this.error = false;
      if (!this.validate()) {
        return this.error;
      }
      return this.parse();
    }

    PlistParser.prototype.validate = function() {
      var parser,
        _this = this;
      parser = this.sax.parser(true);
      parser.ondoctype = function(doctype) {
        if (doctype !== ' plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"') {
          return _this.error = new Error('Invalid DOCTYPE');
        }
      };
      parser.onerror = function(error) {
        return _this.error = error;
      };
      parser.write(this.xml).close();
      if (this.error) {
        return false;
      }
      return true;
    };

    PlistParser.prototype.parse = function() {
      var parser,
        _this = this;
      parser = this.sax.parser(true);
      parser.onopentag = function(node) {
        if (node.name === 'plist') {
          _this.validates = true;
          return;
        } else if (node.name === 'key') {
          _this.last.key = null;
          return;
        }
        if (!_this.traverser) {
          _this.traverser = new PlistNode(node.name);
          return;
        }
        _this.last.node = _this.traverser.addChild(new PlistNode(node.name));
        if (_this.last.key) {
          _this.last.node.key = _this.last.key.valueOf();
          _this.last.key = null;
        }
        if ((node.name === 'dict') || (node.name === 'array')) {
          return _this.traverser = _this.last.node;
        }
      };
      parser.ontext = function(text) {
        return _this.last.value = text;
      };
      parser.onclosetag = function(name) {
        if ((name === 'dict') || (name === 'array')) {
          return _this.traverser = _this.traverser.getParent();
        } else if (name === 'key') {
          if (_this.last.value) {
            _this.last.key = _this.last.value.valueOf();
            return _this.last.value = null;
          }
        } else {
          if (_this.last.value) {
            return _this.last.node.value = _this.last.value.valueOf();
          }
        }
      };
      parser.write(this.xml).close();
      return this.traverser.convert();
    };

    return PlistParser;

  })();

  window.PlistParser = PlistParser;

}).call(this);
